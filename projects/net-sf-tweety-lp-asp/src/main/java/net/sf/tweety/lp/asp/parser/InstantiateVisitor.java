/*
 *  This file is part of "Tweety", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  Tweety is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2016 The Tweety Project Team <http://tweetyproject.org/contact/>
 */
package net.sf.tweety.lp.asp.parser;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import net.sf.tweety.lp.asp.syntax.*;
import net.sf.tweety.lp.asp.util.AnswerSet;
import net.sf.tweety.lp.asp.util.AnswerSetList;
import net.sf.tweety.logics.commons.syntax.Constant;
import net.sf.tweety.logics.commons.syntax.FunctionalTerm;
import net.sf.tweety.logics.commons.syntax.Functor;
import net.sf.tweety.logics.commons.syntax.NumberTerm;
import net.sf.tweety.logics.commons.syntax.Variable;
import net.sf.tweety.logics.commons.syntax.interfaces.Term;

/**
 * This visitor uses an AST generated by the ASPParser and allocates
 * the classes representing the constructs of a source file, like
 * programs, rules, literals, arithmetics, relations, terms, answer sets 
 * etc.
 * 
 * @author Tim Janus
 */
public class InstantiateVisitor implements ASPParserVisitor {	
	
	@Override
	public Object visit(SimpleNode node, Object data) {
		throw new RuntimeException();
	}
	
	@Override
	public Program visit(ASTProgram node, Object data) {
		Program reval = new Program();
		for(int i=0; i<node.jjtGetNumChildren(); ++i) {
			Rule r = visit((ASTRule)node.jjtGetChild(i), null);
			reval.add(r);
		}
		return reval;
	}
	

	@Override
	public Rule visit(ASTRule node, Object data) {
		Rule reval = new Rule();
		for(int i=0; i<node.jjtGetNumChildren(); ++i) {
			if(node.jjtGetChild(i) instanceof ASTHead) {
				DLPHead head = new DLPHead();
				head.addAll(visit((ASTHead) node.jjtGetChild(i), null));
				reval.setConclusion(head);
			} else if(node.jjtGetChild(i) instanceof ASTElementLst) {
				reval.addPremises(visit((ASTElementLst) node.jjtGetChild(i), null));
			}
		}
		return reval;
	}

	@Override
	public Set<DLPLiteral> visit(ASTHead node, Object data) {
		Set<DLPLiteral> reval = new HashSet<DLPLiteral>();
		for(int i=0; i<node.jjtGetNumChildren(); ++i) {
			reval.add(visit((ASTAtom)node.jjtGetChild(i), null));
		}
		return reval;
	}

	@Override
	public Set<DLPElement> visit(ASTElementLst node, Object data) {
		Set<DLPElement> reval = new HashSet<DLPElement>();
		for(int i=0; i<node.jjtGetNumChildren(); ++i) {
			reval.add((DLPElement) node.jjtGetChild(i).jjtAccept(this, null));
		}
		return reval;
	}

	@Override
	public Comparative visit(ASTComparative node, Object data) {
		Node firstChild = node.jjtGetChild(0);
		Node op, l, r;
		String operator;
		Term<?> left, right;
		
		// Differentiate between <(X,Y) and X<Y by mapping child nodes:
		if(firstChild instanceof ASTCompareOp) {
			op = firstChild;
			l = node.jjtGetChild(1);
			r = node.jjtGetChild(2);
		} else {
			l = firstChild;
			op = node.jjtGetChild(1);
			r = node.jjtGetChild(2);
		}
		
		// visit child nodes to get parts of the comparative
		operator = (String) op.jjtAccept(this, null);
		left = (Term<?>) l.jjtAccept(this, null);
		right = (Term<?>) r.jjtAccept(this, null);
		return new Comparative(operator, left, right);
	}

	@Override
	public Arithmetic visit(ASTArithmetic node, Object data) {
		// Differentiate between arithmetic and build-in function like #mod 
		if(! (node.jjtGetChild(0) instanceof ASTSpecId)) {
			Term<?> left, right, res;
			String opStr;
			Node l, ri, re, op;
			
			// Differentiate between +(X,Y,Z) and Z=X+Y to map child nodes
			if(node.jjtGetChild(0) instanceof ASTArithmeticOp) {
				op = node.jjtGetChild(0);
				l = node.jjtGetChild(1);
				ri = node.jjtGetChild(2);
				re = node.jjtGetChild(3);
			} else {
				re = node.jjtGetChild(0);
				l = node.jjtGetChild(1);
				op = node.jjtGetChild(2);
				ri = node.jjtGetChild(3);
			}
			
			// visit other nodes to gather parts of the arithmetic
			opStr = (String)op.jjtAccept(this, null);
			left = (Term<?>)l.jjtAccept(this, null);
			right = (Term<?>) ri.jjtAccept(this, null);
			res = (Term<?>) re.jjtAccept(this, null);
			
			return new Arithmetic(opStr, left, right, res);
		} else {
			String operator = (String)node.jjtGetChild(0).jjtAccept(this, null);
			Term<?> args [] = new Term<?>[3];
			
			for(int i=1; i<node.jjtGetNumChildren(); ++i) {
				args[i-1] = (Term<?>)node.jjtGetChild(i).jjtAccept(this, null);
			}
			
			return new Arithmetic(operator, args[0], args[1], args[2]);
		}
	}

	@Override
	public DLPElement visit(ASTDefAtom node, Object data) {
		DLPLiteral lit = (DLPLiteral)node.jjtGetChild(0).jjtAccept(this, null);
		return node.defNeg ? new DLPNot(lit) : lit;
	}
	
	@Override
	public DLPLiteral visit(ASTAtom node, Object data) {
		DLPAtom reval = null;
		ASTIdentifier ident = (ASTIdentifier) node.jjtGetChild(0);
		if(node.jjtGetNumChildren() == 2) {
			reval = new DLPAtom(ident.name, 
					visit((ASTTermLst)node.jjtGetChild(1), null));
		} else {
			reval = new DLPAtom(ident.name);
		}
		return node.neg ? new DLPNeg(reval) : reval;
	}
	
	@Override
	public List<Term<?>> visit(ASTTermLst node, Object data) {
		List<Term<?>> reval = new LinkedList<Term<?>>();
		for(int i=0; i<node.jjtGetNumChildren(); ++i) {
			Term<?> term = (Term<?>)node.jjtGetChild(i).jjtAccept(this, null);
			reval.add(term);
		}
		return reval;
	}

	@Override
	public SetTerm visit(ASTSetTerm node, Object data) {
		if(node.jjtGetNumChildren() > 0)
			return new SetTerm(visit((ASTTermLst)node.jjtGetChild(0), null));
		else 
			return new SetTerm();
	}

	@Override
	public Term<?> visit(ASTListTail node, Object data) {
		if(node.jjtGetNumChildren() == 1) {
			return visit((ASTListTerm) node.jjtGetChild(0), null);
		} else {
			return new Variable(node.variableName);
		}
	}
	
	@Override
	public ListTerm visit(ASTListTerm node, Object data) {
		int num = node.jjtGetNumChildren();
		if(num == 0) {
			return new ListTerm(new ListTermValue());
		} else if (node.jjtGetChild(num-1) instanceof ASTListTail) {
			Term<?> head = visit((ASTTerm) node.jjtGetChild(0), null);
			Term<?> tail = visit((ASTListTail) node.jjtGetChild(1), null);
			return new ListTerm(new ListTermValue(head, tail));
		} else {
			List<Term<?>> terms = new LinkedList<Term<?>>();
			for(int i=0; i<num; ++i) {
				terms.add(visit((ASTTerm) node.jjtGetChild(i), null));
			}
			return new ListTerm(new ListTermValue(terms));	
		}
	}
	
	@Override
	public FunctionalTerm visit(ASTFunctionalTerm node, Object data) {
		Functor functor = new Functor(node.functor);
		if(node.jjtGetChild(0) instanceof ASTTermLst) {
			return new FunctionalTerm(functor,
					visit((ASTTermLst)node.jjtGetChild(0), null));
		}
		return null;
	}
	
	@Override
	public Term<?> visit(ASTTerm node, Object data) {
		if(node.jjtGetNumChildren() == 1) {
			Node child = node.jjtGetChild(0);
			if(child instanceof ASTNumber) {
				int n = ((ASTNumber)child).number;
				return new NumberTerm(n);
			} else if(child instanceof ASTListTerm 		||
					  child instanceof ASTSetTerm  		||
					  child instanceof ASTSimpleTerm	||
					  child instanceof ASTFunctionalTerm) {
				return (Term<?>) child.jjtAccept(this, null);
			}
		}
		
		//@todo error handling
		return null;
	}

	@Override
	public Term<?> visit(ASTSimpleTerm node, Object data) {
		if(node.jjtGetChild(0) instanceof ASTIdentifier) {
			ASTIdentifier cnode = (ASTIdentifier)node.jjtGetChild(0);
			String name = cnode.name;
			return cnode.variable ? new Variable(name) : new Constant(name);
		} else {
			ASTNumber cnode = (ASTNumber)node.jjtGetChild(0);
			return new NumberTerm(cnode.number);
		}
	}
	
	@Override
	public List<String> visit(ASTIdLst node, Object data) {
		List<String> reval = new LinkedList<String>();
		for(int i=0; i<node.jjtGetNumChildren(); ++i) {
			ASTIdentifier astId = (ASTIdentifier)node.jjtGetChild(i);
			reval.add(astId.name);
		}
		return reval;
	}
	
	@Override
	public Term<?> visit(ASTArithmeticInteger node, Object data) {
		if(node.jjtGetNumChildren() == 0) {
			return new Variable(node.variableName);
		} else {
			return new NumberTerm((Integer)node.jjtGetChild(0).jjtAccept(this, null));
		}
	}

	@Override
	public String visit(ASTCompareOp node, Object data) {
		return node.operator;
	}

	@Override
	public String visit(ASTArithmeticOp node, Object data) {
		return node.operator;
	}
	
	@Override
	public Integer visit(ASTNumber node, Object data) {
		return node.number;
	}
	
	@Override
	public String visit(ASTSpecId node, Object data) {
		return "#" + (String)node.jjtGetChild(0).jjtAccept(this, null);
	}
	
	@Override
	public String visit(ASTIdentifier node, Object data) {
		return node.name;
	}

	@Override
	public Aggregate visit(ASTAggregate node, Object data) {
		// zero means no operator and no Identifier read yet
		// -1 means Identifier read but no operator beforehand
		// 1 means left guard and operator read
		int operatorBefore = 0;
		// used for Aggregate creation:
		SymbolicSet ss = null;
		String functor = null;
		Term<?> left = null, right = null;
		String leftOp = null, rightOp = null;
		
		for(int i=0; i<node.jjtGetNumChildren(); ++i) {
			Object childReval = node.jjtGetChild(i).jjtAccept(this, null); 
			
			if(node.jjtGetChild(i) instanceof ASTCompareOp) {
				if(operatorBefore == 0) {
					operatorBefore = 1;
					leftOp = (String)childReval;
				} else {
					rightOp = (String)childReval;
				}
			} else if(node.jjtGetChild(i) instanceof ASTArithmeticInteger) {
				if(operatorBefore == 0) {
					left = (Term<?>) childReval;
				} else {
					right = (Term<?>) childReval;
				}
			} else if(node.jjtGetChild(i) instanceof ASTSpecId) {
				functor = (String)childReval;
				if(operatorBefore == 0) {
					operatorBefore = -1;
				}
			} else if(node.jjtGetChild(i) instanceof ASTSymbolicSet) {
				ss = (SymbolicSet)childReval;
			}
		}
		
		return new Aggregate(left, leftOp, functor, ss, rightOp, right);
	}

	@Override
	public SymbolicSet visit(ASTSymbolicSet node, Object data) {
		List<DLPElement> literals = new LinkedList<DLPElement>();
		for(int i=0; i<node.jjtGetNumChildren(); ++i) {
			literals.add((DLPElement)node.jjtGetChild(i).jjtAccept(this, null));
		}
		return new SymbolicSet(node.variables, literals);
	}

	@Override
	public AnswerSetList visit(ASTAnswerSetList node, Object data) {
		AnswerSetList asl = new AnswerSetList();
		for(int i=0; i<node.jjtGetNumChildren(); ++i) {
			asl.add((AnswerSet) node.jjtGetChild(i).jjtAccept(this, null));
		}
		return asl;
	}

	@Override
	public AnswerSet visit(ASTAnswerSet node, Object data) {
		AnswerSet as = new AnswerSet();
		for(int i=0; i<node.jjtGetNumChildren(); ++i) {
			DLPLiteral literal = (DLPLiteral)node.jjtGetChild(i).jjtAccept(this, null);
			as.add(literal);
		}
		return as;
	}
}
