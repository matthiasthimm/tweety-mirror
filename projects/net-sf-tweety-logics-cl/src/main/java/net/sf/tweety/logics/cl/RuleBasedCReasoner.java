package net.sf.tweety.logics.cl;


import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import net.sf.tweety.Answer;
import net.sf.tweety.Formula;
import net.sf.tweety.Reasoner;
import net.sf.tweety.logics.cl.kappa.ConditionalStructureKappaBuilder;
import net.sf.tweety.logics.cl.kappa.KappaValue;
import net.sf.tweety.logics.cl.rules.EvaluateRule;
import net.sf.tweety.logics.cl.semantics.ConditionalStructure;
import net.sf.tweety.logics.cl.semantics.RankingFunction;
import net.sf.tweety.logics.cl.semantics.ConditionalStructure.Generator;
import net.sf.tweety.logics.cl.syntax.Conditional;
import net.sf.tweety.logics.pl.semantics.NicePossibleWorld;

/**
 * This is a reasoner using c-representation and rules to solve these c-representations.
 * It contains a list of rules whereby the first rule is the rule with the highest priorization,
 * that means it is applied first. 
 *  
 * @author Tim Janus
 */
public class RuleBasedCReasoner extends Reasoner {
	
	/** 
	 * A rule that is applicable by the {@link RuleBasedCReasoner} to reason a
	 * c-representation given a conditional belief base. Implementation of
	 * this interface can be added to the {@link RuleBasedCReasoner} to adapt
	 * its behavior, such that a {@link RuleBasedCReasoner} can use different rules
	 * if it can make different assumptions on the underlying belief base.
	 * 
	 * @author Tim Janus
	 */
	public static interface Rule {
		/**
		 * Sets the {@link ConditionalStructure} that is used as data basis
		 * for the rule.
		 * @param cs
		 */
		void setConditonalStructure(ConditionalStructure cs);
		
		/**
		 * Sets the Collection of {@link KappaValue} that is used as data basis
		 * for the rule 
		 * @param kappas
		 */
		void setKappas(Collection<KappaValue> kappas);
		
		/** 
		 * Applies the rule
		 * @return true if a change occured, false otherwise
		 */
		boolean apply();
	}
	
	/** the belief base that is reasoned on */
	private ClBeliefSet beliefBase;
	
	/** the conditional structure generated by the belief base of this reasoner, is null until prepare() is called. */
	private ConditionalStructure cs;
	
	/** the map of conditions to their penalty values (kappa), is null until prepare() is called */
	private Map<Conditional, KappaValue> kappas;
	
	/** The ranking function representing the c-representation of the given belief base, is null until process() returns true */
	private RankingFunction rfunc;
	
	/** 
	 * a flag indicating if a human friend processing shall be used, that means
	 * everything is calculated no fast-evaluation, such that a human can better
	 * follow the algorithm.
	 */
	private boolean humanFriendly;
	
	/**
	 * A prioritized list of rules, the first rule is applied first and so on.
	 * If a progress is caused by applying the rule then the first rule is applied
	 * next again.
	 */
	private List<Rule> rules = new ArrayList<RuleBasedCReasoner.Rule>();
	
	public RuleBasedCReasoner(Collection<Conditional> conditionals) {
		this(new ClBeliefSet(conditionals));
	}
	
	public RuleBasedCReasoner(Collection<Conditional> conditionals, boolean humanFriendly) {
		this(new ClBeliefSet(conditionals), humanFriendly);
	}
	
	public RuleBasedCReasoner(ClBeliefSet beliefBase) {
		this(beliefBase, true);
	}
	
	public RuleBasedCReasoner(ClBeliefSet beliefBase, boolean humanFriendly) {
		super(beliefBase);
		
		this.beliefBase = (ClBeliefSet)beliefBase;
		this.humanFriendly = humanFriendly;
	}
	
	/**
	 * @return the c-representation of the belief base as a ranking function
	 */
	public RankingFunction getSemantic() {
		if(rfunc == null) { 
			if(!isComplete()) {
				if(!process()) {
					return null;
				}
			}
			
			rfunc = new RankingFunction(beliefBase.getSignature());
			for(NicePossibleWorld npw : cs.getPossibleWorlds()) {
				int weight = 0;
				for(Entry<Conditional, Generator> entry : cs.getWorldGenerators(npw).entrySet()) {
					if(entry.getValue() == Generator.CG_MINUS)
						weight += kappas.get(entry.getKey()).value();
				}
				rfunc.setRank(npw.getOptimizedWorld(), weight);
			}
		}
		
		return rfunc;
	}
	
	/**
	 * Processes the kappa values using the rules stored in the prioritzed rule list.
	 * It applies the rules by their priority until no changes occurred after every rule
	 * is applied.
	 * @return	true if the processing of the kappa values is complete, false if it is not complete.
	 */
	public boolean process() {
		prepare();
		for(int i=0; i<rules.size(); ++i) {
			if(rules.get(i).apply()) {
				if(isComplete())
					return true;
				
				// otherwise start by re-applying the first rule:
				i = -1;
			}
		}
		
		// if we reach this block no change are possible using the current rules and
		// therefore we return false:
		return false;
	}

	/**
	 * Checks every kappa value.
	 * @return	true if every kappa value is evaluated, false otherwise
	 */
	public boolean isComplete() {
		// check if the kappas are completely processed:
		boolean complete = true;
		for(KappaValue kappa : kappas.values()) {
			if(kappa.value() == -1) {
				complete = false;
				break;
			}
		}
		
		return complete;
	}

	/** 
	 * Prepares the data structures: {@link ConditionalStructure} and the list of {@link KappaValue}, such
	 * that the rules can be applied on them.
	 */
	public void prepare() {
		if(cs == null) {
			cs = new ConditionalStructure(this.beliefBase);
			ConditionalStructureKappaBuilder builder = new ConditionalStructureKappaBuilder(!humanFriendly);
			kappas = new HashMap<Conditional, KappaValue>(builder.build(cs));
			
			// todo: Move rule creation somewhere else and make it more dynamic
			EvaluateRule rule = new EvaluateRule();
			rule.setConditonalStructure(cs);
			rule.setKappas(kappas.values());
			rules.add(rule);
		}
	}
	
	/** @return An unmodifiable list containing the kappa values used by the reasoner or null if the reasoner is not prepared yet */
	public Collection<KappaValue> getKappas() {
		return kappas == null ? null : Collections.unmodifiableCollection(kappas.values());
	}
	
	/** @return The conditional structure used by the reasoner or null if the reasoner is not prepared yet */
	public ConditionalStructure getConditionalStructure() {
		return cs;
	}

	@Override
	public Answer query(Formula query) {
		return null;
	}

}
